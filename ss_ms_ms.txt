
model {

  ### (1) Priors
  ## Omega
  for (i in 1:ncell){
    logit(psi[i]) <- alpha.lpsi[region[i]] + beta.lpsi[1] * elev[i] + beta.lpsi[2] * elev[i]^2 + beta.lpsi[3] * temp[i] + beta.lpsi[4] * temp[i]^2 + beta.lpsi[5] * physdiv[i] + beta.lpsi[6] * precip[i] + beta.lpsi[7] * forest[i] + beta.lpsi[8] * wetlands[i]
    logit(r[i]) <- alpha.lr[region[i]] + beta.lr[1] * karst[i] + beta.lr[2] * forest[i] + beta.lr[3] * physdiv[i]
  }
  
  # Priors for parameters in the linear models of psi and r
  # Region-specific intercepts
  for (k in 1:6){
    alpha.lpsi[k] <- logit(mean.psi[k])
    mean.psi[k] ~ dunif(0, 1)
    alpha.lr[k] <- logit(mean.r[k])
    mean.r[k] ~ dunif(0, 1)
  }
  
  # Priors for coefficients of covariates in Omega
  for (k in 1:8){
    beta.lpsi[k] ~ dnorm(0, 0.1)
  }
  
  for (k in 1:3){
    beta.lr[k] ~ dnorm(0, 0.1)
  }
  
  ## Theta 
  # Priors for parameters in local occupancy
  theta2 ~ dunif(0, 1)              # Local occupancy when cell has few bats
  for (s in 1:3) {                  # Local occupancy when cell has many bats
    beta[s] ~ dgamma(1, 1)         # Induce Dirichlet prior
    theta3[s] <- beta[s] / sum(beta[])
  }
  
  ## detP
  # Priors for parameters in observation process
  p2 ~ dunif(0, 1)              # detection with few bats locally
  for (s in 1:3) {                  # detection with many bats locally
    alpha[s] ~ dgamma(1, 1)         # Induce Dirichlet prior
    p3[s] <- alpha[s] / sum(alpha[])
  }
  
  ### (2) Define relationships between basic model structure and parameters
  # Define initial state vector
  for (i in 1:ncell){
    Omega[i,1] <- 1 - psi[i]                 # Prob. of no bats
    Omega[i,2] <- psi[i] * (1-r[i])          # Prob. of occ. by a few bats
    Omega[i,3] <- psi[i] * r[i]              # Prob. of occ. by many bats
  }
  
  # Define local occupancy probability matrix (Theta)
  # Order of indices: global state, local state
  Theta[1,1] <- 1
  Theta[1,2] <- 0
  Theta[1,3] <- 0
  Theta[2,1] <- 1-theta2
  Theta[2,2] <- p2
  Theta[2,3] <- 0
  Theta[3,1] <- theta3[1]
  Theta[3,2] <- theta3[2]
  Theta[3,3] <- theta3[3]
  
  # Define observation probability matrix (detP)
  # Order of indices: true local state, observed local state
  detP[1,1] <- 1
  detP[1,2] <- 0.0000001
  detP[1,3] <- 0.0000001
  detP[2,1] <- 1-p2
  detP[2,2] <- p2
  detP[2,3] <- 0.0000001
  detP[3,1] <- p3[1]
  detP[3,2] <- p3[2]
  detP[3,3] <- p3[3]
  
  
  ### (3) Likelihood
  
  # global occupancy
  for (i in 1:ncell){
    z[i] ~ dcat(Omega[i,])
  }
  
  # local occupancy
  for (i in 1:ncell){
    for (j in 1:nsite){
      u[i,j] ~ dcat(Theta[z[i], ])
    }
  }
  
  # detection
  for (i in 1:ncell){
    for (j in 1:nsite){
      for (k in 1:nsurveys){
        y[i,j,k] ~ dcat(detP[u[i,j], ])
      }
    }
  }
}
